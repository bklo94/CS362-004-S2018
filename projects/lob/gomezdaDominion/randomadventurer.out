Some tests failed:

# Passed Tests: 10000
# Failed Tests: 0
All Tests Passed

COVERAGE: randomadventurer.c:
File 'randomadventurer.c'
Lines executed:78.38% of 74
Creating 'randomadventurer.c.gcov'

File 'dominion.c'
Lines executed:5.90% of 610
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
    #####:    8:int compare(const void* a, const void* b){
    #####:    9:   if (*(int*)a > *(int*)b)
    #####:   10:      return 1;
    #####:   11:   if (*(int*)a < *(int*)b)
    #####:   12:      return -1;
    #####:   13:   return 0;
        -:   14:}
        -:   15:
    #####:   16:struct gameState* newGame(){
    #####:   17:   struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:   return g;
        -:   19:}
        -:   20:
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8, int k9, int k10){
    #####:   22:   int* k = malloc(10 * sizeof(int));
    #####:   23:   k[0] = k1;
    #####:   24:   k[1] = k2;
    #####:   25:   k[2] = k3;
    #####:   26:   k[3] = k4;
    #####:   27:   k[4] = k5;
    #####:   28:   k[5] = k6;
    #####:   29:   k[6] = k7;
    #####:   30:   k[7] = k8;
    #####:   31:   k[8] = k9;
    #####:   32:   k[9] = k10;
    #####:   33:   return k;
        -:   34:}
        -:   35:
    #####:   36:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed, struct gameState *state){
        -:   37:   int i, j, it;
        -:   38:   //set up random number generator
    #####:   39:   SelectStream(1);
    #####:   40:   PutSeed((long)randomSeed);
        -:   41:   //check number of players
    #####:   42:   if (numPlayers > MAX_PLAYERS || numPlayers < 2)
    #####:   43:      return -1;
        -:   44:   //set number of players
    #####:   45:   state->numPlayers = numPlayers;
        -:   46:   //check selected kingdom cards are different
    #####:   47:   for (i = 0; i < 10; i++){
    #####:   48:      for (j = 0; j < 10; j++){
    #####:   49:         if (j != i && kingdomCards[j] == kingdomCards[i]){
    #####:   50:            return -1;
        -:   51:         }
        -:   52:      }
        -:   53:   }
        -:   54:   //initialize supply
        -:   55:   ///////////////////////////////
        -:   56:   //set number of Curse cards
    #####:   57:   if (numPlayers == 2)
    #####:   58:      state->supplyCount[curse] = 10;
    #####:   59:   else if (numPlayers == 3)
    #####:   60:      state->supplyCount[curse] = 20;
        -:   61:   else
    #####:   62:      state->supplyCount[curse] = 30;
        -:   63:
        -:   64:   //set number of Victory cards
    #####:   65:   if (numPlayers == 2){
    #####:   66:      state->supplyCount[estate] = 8;
    #####:   67:      state->supplyCount[duchy] = 8;
    #####:   68:      state->supplyCount[province] = 8;
        -:   69:   }
        -:   70:   else{
    #####:   71:      state->supplyCount[estate] = 12;
    #####:   72:      state->supplyCount[duchy] = 12;
    #####:   73:      state->supplyCount[province] = 12;
        -:   74:   }
        -:   75:   //set number of Treasure cards
    #####:   76:   state->supplyCount[copper] = 60 - (7 * numPlayers);
    #####:   77:   state->supplyCount[silver] = 40;
    #####:   78:   state->supplyCount[gold] = 30;
        -:   79:   //set number of Kingdom cards
    #####:   80:   for (i = adventurer; i <= treasure_map; i++){     	//loop all cards
    #####:   81:      for (j = 0; j < 10; j++){           		//loop chosen cards
    #####:   82:         if (kingdomCards[j] == i){
        -:   83:            //check if card is a 'Victory' Kingdom card
    #####:   84:            if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens){
    #####:   85:               if (numPlayers == 2){
    #####:   86:                  state->supplyCount[i] = 8;
        -:   87:               }
        -:   88:               else{
    #####:   89:                  state->supplyCount[i] = 12; }
        -:   90:            }
        -:   91:            else{
    #####:   92:               state->supplyCount[i] = 10;
        -:   93:            }
    #####:   94:            break;
        -:   95:         }
        -:   96:         else{    //card is not in the set choosen for the game
    #####:   97:            state->supplyCount[i] = -1;
        -:   98:         }
        -:   99:      }
        -:  100:   }
        -:  101:   ////////////////////////
        -:  102:   //supply intilization complete
        -:  103:   //set player decks
    #####:  104:   for (i = 0; i < numPlayers; i++){
    #####:  105:      state->deckCount[i] = 0;
    #####:  106:      for (j = 0; j < 3; j++){
    #####:  107:         state->deck[i][j] = estate;
    #####:  108:         state->deckCount[i]++;
        -:  109:      }
    #####:  110:      for (j = 3; j < 10; j++){
    #####:  111:         state->deck[i][j] = copper;
    #####:  112:         state->deckCount[i]++;
        -:  113:      }
        -:  114:   }
        -:  115:   //shuffle player decks
    #####:  116:   for (i = 0; i < numPlayers; i++){
    #####:  117:      if ( shuffle(i, state) < 0 ){
    #####:  118:         return -1;
        -:  119:      }
        -:  120:   }
        -:  121:
        -:  122:   //draw player hands
    #####:  123:   for (i = 0; i < numPlayers; i++){
        -:  124:      //initialize hand size to zero
    #####:  125:      state->handCount[i] = 0;
    #####:  126:      state->discardCount[i] = 0;
        -:  127:      //draw 5 cards
        -:  128:      // for (j = 0; j < 5; j++)
        -:  129:      //	{
        -:  130:      //	  drawCard(i, state);
        -:  131:      //	}
        -:  132:   }
        -:  133:   //set embargo tokens to 0 for all supply piles
    #####:  134:   for (i = 0; i <= treasure_map; i++){
    #####:  135:      state->embargoTokens[i] = 0;
        -:  136:   }
        -:  137:   //initialize first player's turn
    #####:  138:   state->outpostPlayed = 0;
    #####:  139:   state->phase = 0;
    #####:  140:   state->numActions = 1;
    #####:  141:   state->numBuys = 1;
    #####:  142:   state->playedCardCount = 0;
    #####:  143:   state->whoseTurn = 0;
    #####:  144:   state->handCount[state->whoseTurn] = 0;
        -:  145:   //int it; move to top
        -:  146:   //Moved draw cards to here, only drawing at the start of a turn
    #####:  147:   for (it = 0; it < 5; it++){
    #####:  148:      drawCard(state->whoseTurn, state);
        -:  149:   }
    #####:  150:   updateCoins(state->whoseTurn, state, 0);
    #####:  151:   return 0;
        -:  152:}
        -:  153:
    #####:  154:int shuffle(int player, struct gameState *state){
    #####:  155:   int newDeck[MAX_DECK], newDeckPos = 0, card, i;
    #####:  156:   if (state->deckCount[player] < 1)
    #####:  157:      return -1;
    #####:  158:   qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  159:   /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
    #####:  160:   while (state->deckCount[player] > 0){
    #####:  161:      card = floor(Random() * state->deckCount[player]);
    #####:  162:      newDeck[newDeckPos] = state->deck[player][card];
    #####:  163:      newDeckPos++;
    #####:  164:      for (i = card; i < state->deckCount[player]-1; i++){
    #####:  165:         state->deck[player][i] = state->deck[player][i+1];
        -:  166:      }
    #####:  167:      state->deckCount[player]--;
        -:  168:   }
    #####:  169:   for (i = 0; i < newDeckPos; i++){
    #####:  170:      state->deck[player][i] = newDeck[i];
    #####:  171:      state->deckCount[player]++;
        -:  172:   }
    #####:  173:   return 0;
        -:  174:}
        -:  175:
    #####:  176:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state){
        -:  177:   int card;
    #####:  178:   int coin_bonus = 0; 		//tracks coins gain from actions
        -:  179:   //check if it is the right phase
    #####:  180:   if (state->phase != 0){
    #####:  181:      return -1;
        -:  182:   }
        -:  183:   //check if player has enough actions
    #####:  184:   if ( state->numActions < 1 ){
    #####:  185:      return -1;
        -:  186:   }
        -:  187:   //get card played
    #####:  188:   card = handCard(handPos, state);
        -:  189:   //check if selected card is an action
    #####:  190:   if ( card < adventurer || card > treasure_map ){
    #####:  191:      return -1;
        -:  192:   }
        -:  193:   //play card
    #####:  194:   if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 ){
    #####:  195:      return -1;
        -:  196:   }
        -:  197:   //reduce number of actions
    #####:  198:   state->numActions--;
        -:  199:   //update coins (Treasure cards may be added with card draws)
    #####:  200:   updateCoins(state->whoseTurn, state, coin_bonus);
    #####:  201:   return 0;
        -:  202:}
        -:  203:
    #####:  204:int buyCard(int supplyPos, struct gameState *state){
        -:  205:   int who;
        -:  206:   if (DEBUG){
        -:  207:      printf("Entering buyCard...\n");
        -:  208:   }
        -:  209:   // I don't know what to do about the phase thing.
    #####:  210:   who = state->whoseTurn;
    #####:  211:   if (state->numBuys < 1){
        -:  212:      if (DEBUG)
        -:  213:      printf("You do not have any buys left\n");
    #####:  214:      return -1;
        -:  215:   }
    #####:  216:   else if (supplyCount(supplyPos, state) <1){
        -:  217:      if (DEBUG)
        -:  218:      printf("There are not any of that type of card left\n");
    #####:  219:      return -1;
        -:  220:   }
    #####:  221:   else if (state->coins < getCost(supplyPos)){
        -:  222:      if (DEBUG)
        -:  223:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  224:      return -1;
        -:  225:   }
        -:  226:   else{
    #####:  227:      state->phase=1;
        -:  228:      //state->supplyCount[supplyPos]--;
    #####:  229:      gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
    #####:  230:      state->coins = (state->coins) - (getCost(supplyPos));
    #####:  231:      state->numBuys--;
        -:  232:      if (DEBUG)
        -:  233:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  234:   }
        -:  235:
        -:  236:   //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  237:   //state->discardCount[who]++;
        -:  238:
    #####:  239:   return 0;
        -:  240:}
        -:  241:
    #####:  242:int numHandCards(struct gameState *state){
    #####:  243:   return state->handCount[ whoseTurn(state) ];
        -:  244:}
        -:  245:
    #####:  246:int handCard(int handPos, struct gameState *state){
    #####:  247:   int currentPlayer = whoseTurn(state);
    #####:  248:   return state->hand[currentPlayer][handPos];
        -:  249:}
        -:  250:
    #####:  251:int supplyCount(int card, struct gameState *state){
    #####:  252:   return state->supplyCount[card];
        -:  253:}
        -:  254:
    #####:  255:int fullDeckCount(int player, int card, struct gameState *state){
        -:  256:   int i;
    #####:  257:   int count = 0;
    #####:  258:   for (i = 0; i < state->deckCount[player]; i++){
    #####:  259:      if (state->deck[player][i] == card) count++;
        -:  260:   }
    #####:  261:   for (i = 0; i < state->handCount[player]; i++){
    #####:  262:      if (state->hand[player][i] == card) count++;
        -:  263:   }
    #####:  264:   for (i = 0; i < state->discardCount[player]; i++){
    #####:  265:      if (state->discard[player][i] == card) count++;
        -:  266:   }
    #####:  267:   return count;
        -:  268:}
        -:  269:
    10000:  270:int whoseTurn(struct gameState *state){
    10000:  271:   return state->whoseTurn;
        -:  272:}
        -:  273:
    #####:  274:int endTurn(struct gameState *state){
        -:  275:   int k, i;
    #####:  276:   int currentPlayer = whoseTurn(state);
        -:  277:   //Discard hand
    #####:  278:   for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  279:      state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  280:      state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  281:   }
    #####:  282:   state->handCount[currentPlayer] = 0;//Reset hand count
        -:  283:   //Code for determining the player
    #####:  284:   if (currentPlayer < (state->numPlayers - 1)){
    #####:  285:      state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  286:   }
        -:  287:   else{
    #####:  288:      state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  289:   }
    #####:  290:   state->outpostPlayed = 0;
    #####:  291:   state->phase = 0;
    #####:  292:   state->numActions = 1;
    #####:  293:   state->coins = 0;
    #####:  294:   state->numBuys = 1;
    #####:  295:   state->playedCardCount = 0;
    #####:  296:   state->handCount[state->whoseTurn] = 0;
        -:  297:   //int k; move to top
        -:  298:   //Next player draws hand
    #####:  299:   for (k = 0; k < 5; k++){
    #####:  300:      drawCard(state->whoseTurn, state);//Draw a card
        -:  301:   }
        -:  302:   //Update money
    #####:  303:   updateCoins(state->whoseTurn, state , 0);
    #####:  304:   return 0;
        -:  305:}
        -:  306:
    #####:  307:int isGameOver(struct gameState *state){
        -:  308:   int i, j;
        -:  309:   //if stack of Province cards is empty, the game ends
    #####:  310:   if (state->supplyCount[province] == 0){
    #####:  311:      return 1;
        -:  312:   }
        -:  313:   //if three supply pile are at 0, the game ends
    #####:  314:   j = 0;
    #####:  315:   for (i = 0; i < 25; i++){
    #####:  316:      if (state->supplyCount[i] == 0){
    #####:  317:         j++;
        -:  318:      }
        -:  319:   }
    #####:  320:   if ( j >= 3){
    #####:  321:      return 1;
        -:  322:   }
    #####:  323:   return 0;
        -:  324:}
        -:  325:
    #####:  326:int scoreFor (int player, struct gameState *state){
    #####:  327:   int i, score = 0;
        -:  328:   //score from hand
    #####:  329:   for (i = 0; i < state->handCount[player]; i++){
    #####:  330:      if (state->hand[player][i] == curse){ score = score - 1; };
    #####:  331:      if (state->hand[player][i] == estate){ score = score + 1; };
    #####:  332:      if (state->hand[player][i] == duchy){ score = score + 3; };
    #####:  333:      if (state->hand[player][i] == province){ score = score + 6; };
    #####:  334:      if (state->hand[player][i] == great_hall){ score = score + 1; };
    #####:  335:      if (state->hand[player][i] == gardens){ score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  336:   }
        -:  337:   //score from discard
    #####:  338:   for (i = 0; i < state->discardCount[player]; i++){
    #####:  339:      if (state->discard[player][i] == curse){ score = score - 1; };
    #####:  340:      if (state->discard[player][i] == estate){ score = score + 1; };
    #####:  341:      if (state->discard[player][i] == duchy){ score = score + 3; };
    #####:  342:      if (state->discard[player][i] == province){ score = score + 6; };
    #####:  343:      if (state->discard[player][i] == great_hall){ score = score + 1; };
    #####:  344:      if (state->discard[player][i] == gardens){ score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  345:   }
        -:  346:   //score from deck
    #####:  347:   for (i = 0; i < state->discardCount[player]; i++){
    #####:  348:      if (state->deck[player][i] == curse){ score = score - 1; };
    #####:  349:      if (state->deck[player][i] == estate){ score = score + 1; };
    #####:  350:      if (state->deck[player][i] == duchy){ score = score + 3; };
    #####:  351:      if (state->deck[player][i] == province){ score = score + 6; };
    #####:  352:      if (state->deck[player][i] == great_hall){ score = score + 1; };
    #####:  353:      if (state->deck[player][i] == gardens){ score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  354:   }
    #####:  355:   return score;
        -:  356:}
        -:  357:
    #####:  358:int getWinners(int players[MAX_PLAYERS], struct gameState *state){
        -:  359:   int i, j, highScore, currentPlayer;
        -:  360:   //get score for each player
    #####:  361:   for (i = 0; i < MAX_PLAYERS; i++){
        -:  362:      //set unused player scores to -9999
    #####:  363:      if (i >= state->numPlayers){
    #####:  364:         players[i] = -9999;
        -:  365:      }
        -:  366:      else{
    #####:  367:         players[i] = scoreFor (i, state);
        -:  368:      }
        -:  369:   }
        -:  370:   //find highest score
    #####:  371:   j = 0;
    #####:  372:   for (i = 0; i < MAX_PLAYERS; i++){
    #####:  373:      if (players[i] > players[j]){
    #####:  374:         j = i;
        -:  375:      }
        -:  376:   }
    #####:  377:   highScore = players[j];
        -:  378:   //add 1 to players who had less turns
    #####:  379:   currentPlayer = whoseTurn(state);
    #####:  380:   for (i = 0; i < MAX_PLAYERS; i++){
    #####:  381:      if ( players[i] == highScore && i > currentPlayer ){
    #####:  382:         players[i]++;
        -:  383:      }
        -:  384:   }
        -:  385:   //find new highest score
    #####:  386:   j = 0;
    #####:  387:   for (i = 0; i < MAX_PLAYERS; i++){
    #####:  388:      if ( players[i] > players[j] ){
    #####:  389:         j = i;
        -:  390:      }
        -:  391:   }
    #####:  392:   highScore = players[j];
        -:  393:   //set winners in array to 1 and rest to 0
    #####:  394:   for (i = 0; i < MAX_PLAYERS; i++){
    #####:  395:      if ( players[i] == highScore ){
    #####:  396:         players[i] = 1;
        -:  397:      }
        -:  398:      else{
    #####:  399:         players[i] = 0;
        -:  400:      }
        -:  401:   }
    #####:  402:   return 0;
        -:  403:}
        -:  404:
  2525556:  405:int drawCard(int player, struct gameState *state){
        -:  406:   int count, deckCounter;
  2525556:  407:   if (state->deckCount[player] <= 0){//Deck is empty
        -:  408:      //Step 1 Shuffle the discard pile back into a deck
        -:  409:      int i;
        -:  410:      //Move discard to deck
    #####:  411:      for (i = 0; i < state->discardCount[player];i++){
    #####:  412:         state->deck[player][i] = state->discard[player][i];
    #####:  413:         state->discard[player][i] = -1;
        -:  414:      }
    #####:  415:      state->deckCount[player] = state->discardCount[player];
    #####:  416:      state->discardCount[player] = 0;//Reset discard
        -:  417:      //Shufffle the deck
    #####:  418:      shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  419:      if (DEBUG){//Debug statements
        -:  420:         printf("Deck count now: %d\n", state->deckCount[player]);
        -:  421:      }
    #####:  422:      state->discardCount[player] = 0;
        -:  423:      //Step 2 Draw Card
    #####:  424:      count = state->handCount[player];//Get current player's hand count
        -:  425:      if (DEBUG){//Debug statements
        -:  426:         printf("Current hand count: %d\n", count);
        -:  427:      }
    #####:  428:      deckCounter = state->deckCount[player];//Create a holder for the deck count
    #####:  429:      if (deckCounter == 0)
    #####:  430:         return -1;
    #####:  431:      state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  432:      state->deckCount[player]--;
    #####:  433:      state->handCount[player]++;//Increment hand count
        -:  434:   }
        -:  435:   else{
  2525556:  436:      int count = state->handCount[player];//Get current hand count for player
        -:  437:      int deckCounter;
        -:  438:      if (DEBUG){//Debug statements
        -:  439:         printf("Current hand count: %d\n", count);
        -:  440:      }
  2525556:  441:      deckCounter = state->deckCount[player];//Create holder for the deck count
  2525556:  442:      state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
  2525556:  443:      state->deckCount[player]--;
  2525556:  444:      state->handCount[player]++;//Increment hand count
        -:  445:   }
  2525556:  446:   return 0;
        -:  447:}
        -:  448:
    #####:  449:int getCost(int cardNumber){
    #####:  450:   switch(cardNumber){
    #####:  451:      case curse:
    #####:  452:         return 0;
    #####:  453:      case estate:
    #####:  454:         return 2;
    #####:  455:      case duchy:
    #####:  456:         return 5;
    #####:  457:      case province:
    #####:  458:         return 8;
    #####:  459:      case copper:
    #####:  460:         return 0;
    #####:  461:      case silver:
    #####:  462:         return 3;
    #####:  463:      case gold:
    #####:  464:         return 6;
    #####:  465:      case adventurer:
    #####:  466:         return 6;
    #####:  467:      case council_room:
    #####:  468:         return 5;
    #####:  469:      case feast:
    #####:  470:         return 4;
    #####:  471:      case gardens:
    #####:  472:         return 4;
    #####:  473:      case mine:
    #####:  474:         return 5;
    #####:  475:      case remodel:
    #####:  476:         return 4;
    #####:  477:      case smithy:
    #####:  478:         return 4;
    #####:  479:      case village:
    #####:  480:         return 3;
    #####:  481:      case baron:
    #####:  482:         return 4;
    #####:  483:      case great_hall:
    #####:  484:         return 3;
    #####:  485:      case minion:
    #####:  486:         return 5;
    #####:  487:      case steward:
    #####:  488:         return 3;
    #####:  489:      case tribute:
    #####:  490:         return 5;
    #####:  491:      case ambassador:
    #####:  492:         return 3;
    #####:  493:      case cutpurse:
    #####:  494:         return 4;
    #####:  495:      case embargo:
    #####:  496:         return 2;
    #####:  497:      case outpost:
    #####:  498:         return 5;
    #####:  499:      case salvager:
    #####:  500:         return 4;
    #####:  501:      case sea_hag:
    #####:  502:         return 4;
    #####:  503:      case treasure_map:
    #####:  504:         return 4;
        -:  505:   }
    #####:  506:   return -1;
        -:  507:}
        -:  508:
    10000:  509:void rAdventurer(struct gameState *state, int z, int temphand[], int currentPlayer)
        -:  510:{
    10000:  511:      int drawntreasure=0;
        -:  512:      int cardDrawn; // declared for refactored independent function
  1282778:  513:      while(drawntreasure<2){
  1262778:  514:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  515:	  shuffle(currentPlayer, state);
        -:  516:	}
  1262778:  517:	drawCard(currentPlayer, state);
  1262778:  518:	cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
        -:  519:	//if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
  1262778:  520:	if (cardDrawn == copper || (cardDrawn == silver || cardDrawn == gold)) // <--BUG
    20000:  521:	  drawntreasure++;
        -:  522:	else{
  1242778:  523:	  temphand[z]=cardDrawn;
  1242778:  524:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
  1242778:  525:	  z++;
        -:  526:	}
        -:  527:      }
  1262778:  528:      while(z-1>=0){
  1242778:  529:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
  1242778:  530:	z=z-1;
        -:  531:      }
    10000:  532:}
        -:  533:
    #####:  534:void rSmithy(int currentPlayer, struct gameState *state, int handPos){
        -:  535:   int i; // needed for the refactored independent function
        -:  536:   //+3 Cards
        -:  537:   //for (i = 0; i < 3; i++)
    #####:  538:   for (i = 0; i < 2; i++) // <- BUG
        -:  539:{
    #####:  540:  drawCard(currentPlayer, state);
        -:  541:}
        -:  542:
        -:  543:   //discard card from hand
    #####:  544:   discardCard(handPos, currentPlayer, state, 0);
    #####:  545:}
        -:  546:
        -:  547:// refactored council_room
    #####:  548:void rCouncil_room(struct gameState *state, int handPos, int currentPlayer)
        -:  549:{
        -:  550:      int i; // declared for refactored independent function
        -:  551:      //+4 Cards
        -:  552:      //for (i = 0; i < 4; i++)
    #####:  553:      for (i = 1; i < 4; i++) // <-- BUG
        -:  554:	{
    #####:  555:	  drawCard(currentPlayer, state);
        -:  556:	}
        -:  557:      //+1 Buy
    #####:  558:      state->numBuys++;
        -:  559:
        -:  560:      //Each other player draws a card
    #####:  561:      for (i = 0; i < state->numPlayers; i++)
        -:  562:	{
    #####:  563:	  if ( i != currentPlayer )
        -:  564:	    {
    #####:  565:	      drawCard(i, state);
        -:  566:	    }
        -:  567:	}
        -:  568:
        -:  569:      //put played card in played card pile
    #####:  570:      discardCard(handPos, currentPlayer, state, 0);
    #####:  571:}
        -:  572:
    #####:  573:void feastCard(int currentPlayer, struct gameState *state, int temphand[], int choice1){
        -:  574:   int i,x;
        -:  575:   //gain card with cost up to 5
        -:  576:   //Backup hand
    #####:  577:   for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  578:      temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  579:      state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  580:   }
        -:  581:   //Backup hand
        -:  582:   //Update Coins for Buy
    #####:  583:   updateCoins(currentPlayer, state, 5);
        -:  584:   //TODO Bug wrong loop condition
    #####:  585:   x = 0;//Condition to loop on
    #####:  586:   while( x == 1){//Buy one card
    #####:  587:      if (supplyCount(choice1, state) <= 0){
        -:  588:         if (DEBUG)
        -:  589:            printf("None of that card left, sorry!\n");
        -:  590:         if (DEBUG){
        -:  591:            printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  592:         }
        -:  593:      }
    #####:  594:      else if (state->coins < getCost(choice1)){
    #####:  595:         printf("That card is too expensive!\n");
        -:  596:         if (DEBUG){
        -:  597:            printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  598:         }
        -:  599:      }
        -:  600:      else{
        -:  601:         if (DEBUG){
        -:  602:            printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  603:         }
    #####:  604:         gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  605:         x = 0;//No more buying cards
        -:  606:         if (DEBUG){
        -:  607:            printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  608:         }
        -:  609:
        -:  610:      }
        -:  611:   }
        -:  612:   //Reset Hand
    #####:  613:   for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  614:      state->hand[currentPlayer][i] = temphand[i];
    #####:  615:      temphand[i] = -1;
        -:  616:   }
        -:  617:   //Reset Hand
    #####:  618:}
        -:  619:
    #####:  620:int mineCard(int currentPlayer, struct gameState *state, int handPos, int choice1, int choice2){
        -:  621:   int i, j;
    #####:  622:   j = state->hand[currentPlayer][choice1];  //store card we will trash
    #####:  623:   if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold){
    #####:  624:      return -1;
        -:  625:   }
    #####:  626:   if (choice2 > treasure_map || choice2 < curse){
    #####:  627:      return -1;
        -:  628:   }
    #####:  629:   if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) ){
    #####:  630:      return -1;
        -:  631:   }
    #####:  632:   gainCard(choice1, state, 1, currentPlayer);
        -:  633:   //discard card from hand
    #####:  634:   discardCard(handPos, currentPlayer, state, 0);
        -:  635:   //discard trashed card
    #####:  636:   for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  637:      if (state->hand[currentPlayer][i] == j){
    #####:  638:         discardCard(i, currentPlayer, state, 0);
    #####:  639:         break;
        -:  640:      }
        -:  641:   }
    #####:  642:   return 0;
        -:  643:}
        -:  644:
    10000:  645:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus){
        -:  646:   int i, j, k, index, y;
    10000:  647:   int currentPlayer = whoseTurn(state);
    10000:  648:   int nextPlayer = currentPlayer + 1;
    10000:  649:   int tributeRevealedCards[2] ={-1, -1};
        -:  650:   int temphand[MAX_HAND];// moved above the if statement
        -:  651:   //int x
        -:  652:   //int drawntreasure=0;
        -:  653:   //int cardDrawn;
    10000:  654:   int z = 0;// this is the counter for the temp hand
    10000:  655:   if (nextPlayer > (state->numPlayers - 1)){
     4977:  656:      nextPlayer = 0;
        -:  657:   }
        -:  658:   //uses switch to select card and perform actions
    10000:  659:   switch( card ){
    10000:  660:      case adventurer:
    10000:  661:         rAdventurer(state, z, temphand, currentPlayer);
    10000:  662:         return 0;
        -:  663:
    #####:  664:      case council_room:
    #####:  665:         rCouncil_room(state, handPos, currentPlayer);
    #####:  666:         return 0;
        -:  667:
    #####:  668:      case feast:
    #####:  669:         feastCard(currentPlayer, state, temphand, choice1);
    #####:  670:         return 0;
        -:  671:
    #####:  672:      case gardens:
    #####:  673:         return -1;
        -:  674:
    #####:  675:      case mine:
    #####:  676:         y = mineCard(currentPlayer, state, handPos, choice1, choice2);
    #####:  677:         return y;
        -:  678:
    #####:  679:      case remodel:
    #####:  680:         j = state->hand[currentPlayer][choice1];  //store card we will trash
    #####:  681:         if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) ){
    #####:  682:            return -1;
        -:  683:         }
    #####:  684:         gainCard(choice2, state, 0, currentPlayer);
        -:  685:         //discard card from hand
    #####:  686:         discardCard(handPos, currentPlayer, state, 0);
        -:  687:         //discard trashed card
    #####:  688:         for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  689:            if (state->hand[currentPlayer][i] == j){
    #####:  690:               discardCard(i, currentPlayer, state, 0);
    #####:  691:               break;
        -:  692:            }
        -:  693:         }
    #####:  694:         return 0;
        -:  695:
    #####:  696:      case smithy:
    #####:  697:         rSmithy(currentPlayer, state, handPos);
    #####:  698:         return 0;
        -:  699:
    #####:  700:      case village:
        -:  701:         //+1 Card
    #####:  702:         drawCard(currentPlayer, state);
        -:  703:         //+2 Actions
    #####:  704:         state->numActions = state->numActions + 2;
        -:  705:         //discard played card from hand
    #####:  706:         discardCard(handPos, currentPlayer, state, 0);
    #####:  707:         return 0;
        -:  708:
    #####:  709:      case baron:
    #####:  710:         state->numBuys++;//Increase buys by 1!
    #####:  711:         if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  712:            int p = 0;//Iterator for hand!
    #####:  713:            int card_not_discarded = 1;//Flag for discard set!
    #####:  714:            while(card_not_discarded){
    #####:  715:               if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  716:                  state->coins += 4;//Add 4 coins to the amount of coins
    #####:  717:                  state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  718:                  state->discardCount[currentPlayer]++;
    #####:  719:                  for (;p < state->handCount[currentPlayer]; p++){
    #####:  720:                     state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  721:                  }
    #####:  722:                  state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  723:                  state->handCount[currentPlayer]--;
    #####:  724:                  card_not_discarded = 0;//Exit the loop
        -:  725:               }
    #####:  726:               else if (p > state->handCount[currentPlayer]){
        -:  727:                  if(DEBUG){
        -:  728:                     printf("No estate cards in your hand, invalid choice\n");
        -:  729:                     printf("Must gain an estate if there are any\n");
        -:  730:                  }
    #####:  731:                  if (supplyCount(estate, state) > 0){
    #####:  732:                     gainCard(estate, state, 0, currentPlayer);
    #####:  733:                     state->supplyCount[estate]--;//Decrement estates
    #####:  734:                     if (supplyCount(estate, state) == 0){
    #####:  735:                        isGameOver(state);
        -:  736:                     }
        -:  737:                  }
    #####:  738:                  card_not_discarded = 0;//Exit the loop
        -:  739:               }
        -:  740:               else{
    #####:  741:                  p++;//Next card
        -:  742:               }
        -:  743:            }
        -:  744:         }
        -:  745:         else{
    #####:  746:            if (supplyCount(estate, state) > 0){
    #####:  747:               gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  748:               state->supplyCount[estate]--;//Decrement Estates
    #####:  749:               if (supplyCount(estate, state) == 0){
    #####:  750:                  isGameOver(state);
        -:  751:               }
        -:  752:            }
        -:  753:         }
    #####:  754:         return 0;
        -:  755:
    #####:  756:      case great_hall:
        -:  757:         //+1 Card
    #####:  758:         drawCard(currentPlayer, state);
        -:  759:         //+1 Actions
    #####:  760:         state->numActions++;
        -:  761:         //discard card from hand
    #####:  762:         discardCard(handPos, currentPlayer, state, 0);
    #####:  763:         return 0;
        -:  764:
    #####:  765:      case minion:
        -:  766:         //+1 action
    #####:  767:         state->numActions++;
        -:  768:         //discard card from hand
    #####:  769:         discardCard(handPos, currentPlayer, state, 0);
    #####:  770:         if (choice1){		//+2 coins
    #####:  771:            state->coins = state->coins + 2;
        -:  772:         }
    #####:  773:         else if (choice2){		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  774:            //discard hand
    #####:  775:            while(numHandCards(state) > 0){
    #####:  776:               discardCard(handPos, currentPlayer, state, 0);
        -:  777:            }
        -:  778:            //draw 4
    #####:  779:            for (i = 0; i < 4; i++){
    #####:  780:               drawCard(currentPlayer, state);
        -:  781:            }
        -:  782:            //other players discard hand and redraw if hand size > 4
    #####:  783:            for (i = 0; i < state->numPlayers; i++){
    #####:  784:               if (i != currentPlayer){
    #####:  785:                  if ( state->handCount[i] > 4 ){
        -:  786:                     //discard hand
    #####:  787:                     while( state->handCount[i] > 0 ){
    #####:  788:                        discardCard(handPos, i, state, 0);
        -:  789:                     }
        -:  790:                     //draw 4
    #####:  791:                     for (j = 0; j < 4; j++){
    #####:  792:                        drawCard(i, state);
        -:  793:                     }
        -:  794:                  }
        -:  795:               }
        -:  796:            }
        -:  797:         }
    #####:  798:         return 0;
        -:  799:
    #####:  800:      case steward:
    #####:  801:         if (choice1 == 1){
        -:  802:            //+2 cards
    #####:  803:            drawCard(currentPlayer, state);
    #####:  804:            drawCard(currentPlayer, state);
        -:  805:         }
    #####:  806:         else if (choice1 == 2){
        -:  807:            //+2 coins
    #####:  808:            state->coins = state->coins + 2;
        -:  809:         }
        -:  810:         else{
        -:  811:            //trash 2 cards in hand
    #####:  812:            discardCard(choice2, currentPlayer, state, 1);
    #####:  813:            discardCard(choice3, currentPlayer, state, 1);
        -:  814:         }
        -:  815:         //discard card from hand
    #####:  816:         discardCard(handPos, currentPlayer, state, 0);
    #####:  817:         return 0;
        -:  818:
    #####:  819:      case tribute:
    #####:  820:         if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  821:            if (state->deckCount[nextPlayer] > 0){
    #####:  822:               tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  823:               state->deckCount[nextPlayer]--;
        -:  824:            }
    #####:  825:            else if (state->discardCount[nextPlayer] > 0){
    #####:  826:               tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  827:               state->discardCount[nextPlayer]--;
        -:  828:            }
        -:  829:            else{
        -:  830:               //No Card to Reveal
        -:  831:               if (DEBUG){
        -:  832:                  printf("No cards to reveal\n");
        -:  833:               }
        -:  834:            }
        -:  835:         }
        -:  836:         else{
    #####:  837:            if (state->deckCount[nextPlayer] == 0){
    #####:  838:               for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  839:                  state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  840:                  state->deckCount[nextPlayer]++;
    #####:  841:                  state->discard[nextPlayer][i] = -1;
    #####:  842:                  state->discardCount[nextPlayer]--;
        -:  843:               }
    #####:  844:               shuffle(nextPlayer,state);//Shuffle the deck
        -:  845:            }
    #####:  846:            tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  847:            state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  848:            state->deckCount[nextPlayer]--;
    #####:  849:            tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  850:            state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  851:            state->deckCount[nextPlayer]--;
        -:  852:         }
    #####:  853:         if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one
    #####:  854:            state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  855:            state->playedCardCount++;
    #####:  856:            tributeRevealedCards[1] = -1;
        -:  857:         }
    #####:  858:         for (i = 0; i <= 2; i ++){
    #####:  859:            if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  860:               state->coins += 2;
        -:  861:            }
    #####:  862:            else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  863:               drawCard(currentPlayer, state);
    #####:  864:               drawCard(currentPlayer, state);
        -:  865:            }
        -:  866:            else{//Action Card
    #####:  867:               state->numActions = state->numActions + 2;
        -:  868:            }
        -:  869:         }
    #####:  870:         return 0;
        -:  871:
    #####:  872:      case ambassador:
    #####:  873:         j = 0;		//used to check if player has enough cards to discard
    #####:  874:         if (choice2 > 2 || choice2 < 0){
    #####:  875:            return -1;
        -:  876:         }
    #####:  877:         if (choice1 == handPos){
    #####:  878:            return -1;
        -:  879:         }
    #####:  880:         for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  881:            if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1){
    #####:  882:               j++;
        -:  883:            }
        -:  884:         }
    #####:  885:         if (j < choice2){
    #####:  886:            return -1;
        -:  887:         }
        -:  888:         if (DEBUG)
        -:  889:         printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  890:         //increase supply count for choosen card by amount being discarded
    #####:  891:         state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  892:         //each other player gains a copy of revealed card
    #####:  893:         for (i = 0; i < state->numPlayers; i++){
    #####:  894:            if (i != currentPlayer){
    #####:  895:               gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -:  896:            }
        -:  897:         }
        -:  898:         //discard played card from hand
    #####:  899:         discardCard(handPos, currentPlayer, state, 0);
        -:  900:         //trash copies of cards returned to supply
    #####:  901:         for (j = 0; j < choice2; j++){
    #####:  902:            for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  903:               if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1]){
    #####:  904:                  discardCard(i, currentPlayer, state, 1);
    #####:  905:                  break;
        -:  906:               }
        -:  907:            }
        -:  908:         }
    #####:  909:         return 0;
        -:  910:
    #####:  911:      case cutpurse:
    #####:  912:         updateCoins(currentPlayer, state, 2);
    #####:  913:         for (i = 0; i < state->numPlayers; i++){
    #####:  914:            if (i != currentPlayer){
    #####:  915:               for (j = 0; j < state->handCount[i]; j++){
    #####:  916:                  if (state->hand[i][j] == copper){
    #####:  917:                     discardCard(j, i, state, 0);
    #####:  918:                     break;
        -:  919:                  }
    #####:  920:                  if (j == state->handCount[i]){
    #####:  921:                     for (k = 0; k < state->handCount[i]; k++){
        -:  922:                        if (DEBUG)
        -:  923:                        printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -:  924:                     }
    #####:  925:                     break;
        -:  926:                  }
        -:  927:               }
        -:  928:
        -:  929:            }
        -:  930:
        -:  931:         }
        -:  932:         //discard played card from hand
    #####:  933:         discardCard(handPos, currentPlayer, state, 0);
    #####:  934:         return 0;
        -:  935:
    #####:  936:      case embargo:
        -:  937:         //+2 Coins
    #####:  938:         state->coins = state->coins + 2;
        -:  939:         //see if selected pile is in play
    #####:  940:         if ( state->supplyCount[choice1] == -1 ){
    #####:  941:            return -1;
        -:  942:         }
        -:  943:         //add embargo token to selected supply pile
    #####:  944:         state->embargoTokens[choice1]++;
        -:  945:         //trash card
    #####:  946:         discardCard(handPos, currentPlayer, state, 1);
    #####:  947:         return 0;
        -:  948:
    #####:  949:      case outpost:
        -:  950:         //set outpost flag
    #####:  951:         state->outpostPlayed++;
        -:  952:         //discard card
    #####:  953:         discardCard(handPos, currentPlayer, state, 0);
    #####:  954:         return 0;
        -:  955:
    #####:  956:      case salvager:
        -:  957:         //+1 buy
    #####:  958:         state->numBuys++;
    #####:  959:         if (choice1){
        -:  960:            //gain coins equal to trashed card
    #####:  961:            state->coins = state->coins + getCost( handCard(choice1, state) );
        -:  962:            //trash card
    #####:  963:            discardCard(choice1, currentPlayer, state, 1);
        -:  964:         }
        -:  965:         //discard card
    #####:  966:         discardCard(handPos, currentPlayer, state, 0);
    #####:  967:         return 0;
        -:  968:
    #####:  969:      case sea_hag:
    #####:  970:         for (i = 0; i < state->numPlayers; i++){
    #####:  971:            if (i != currentPlayer){
    #####:  972:               state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####:  973:               state->discardCount[i]++;
    #####:  974:               state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -:  975:            }
        -:  976:         }
    #####:  977:         return 0;
        -:  978:
    #####:  979:      case treasure_map:
        -:  980:         //search hand for another treasure_map
    #####:  981:         index = -1;
    #####:  982:         for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  983:            if (state->hand[currentPlayer][i] == treasure_map && i != handPos){
    #####:  984:               index = i;
    #####:  985:               break;
        -:  986:            }
        -:  987:         }
    #####:  988:         if (index > -1){
        -:  989:            //trash both treasure cards
    #####:  990:            discardCard(handPos, currentPlayer, state, 1);
    #####:  991:            discardCard(index, currentPlayer, state, 1);
        -:  992:
        -:  993:            //gain 4 Gold cards
    #####:  994:            for (i = 0; i < 4; i++){
    #####:  995:               gainCard(gold, state, 1, currentPlayer);
        -:  996:            }
        -:  997:            //return success
    #####:  998:            return 1;
        -:  999:         }
        -: 1000:         //no second treasure_map found in hand
    #####: 1001:         return -1;
        -: 1002:   }
        -: 1003:
    #####: 1004:   return -1;
        -: 1005:}
        -: 1006:
    #####: 1007:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag){
        -: 1008:   //if card is not trashed, added to Played pile
    #####: 1009:   if (trashFlag < 1){
        -: 1010:      //add card to played pile
    #####: 1011:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
    #####: 1012:      state->playedCardCount++;
        -: 1013:   }
        -: 1014:   //set played card to -1
    #####: 1015:   state->hand[currentPlayer][handPos] = -1;
        -: 1016:   //remove card from player's hand
    #####: 1017:   if ( handPos == (state->handCount[currentPlayer] - 1) ){ 	//last card in hand array is played
        -: 1018:      //reduce number of cards in hand
    #####: 1019:      state->handCount[currentPlayer]--;
        -: 1020:   }
    #####: 1021:   else if ( state->handCount[currentPlayer] == 1 ){ //only one card in hand
        -: 1022:      //reduce number of cards in hand
    #####: 1023:      state->handCount[currentPlayer]--;
        -: 1024:   }
        -: 1025:   else{
        -: 1026:      //replace discarded card with last card in hand
    #####: 1027:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1028:      //set last card to -1
    #####: 1029:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1030:      //reduce number of cards in hand
    #####: 1031:      state->handCount[currentPlayer]--;
        -: 1032:   }
    #####: 1033:   return 0;
        -: 1034:}
        -: 1035:
    #####: 1036:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player){
        -: 1037:   //Note: supplyPos is enum of choosen card
        -: 1038:   //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1039:   if ( supplyCount(supplyPos, state) < 1 ){
    #####: 1040:      return -1;
        -: 1041:   }
        -: 1042:   //added card for [whoseTurn] current player:
        -: 1043:   // toFlag = 0 : add to discard
        -: 1044:   // toFlag = 1 : add to deck
        -: 1045:   // toFlag = 2 : add to hand
    #####: 1046:   if (toFlag == 1){
    #####: 1047:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1048:      state->deckCount[player]++;
        -: 1049:   }
    #####: 1050:   else if (toFlag == 2){
    #####: 1051:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1052:      state->handCount[player]++;
        -: 1053:   }
        -: 1054:   else{
    #####: 1055:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1056:      state->discardCount[player]++;
        -: 1057:   }
        -: 1058:   //decrease number in supply pile
    #####: 1059:   state->supplyCount[supplyPos]--;
    #####: 1060:   return 0;
        -: 1061:}
        -: 1062:
    #####: 1063:int updateCoins(int player, struct gameState *state, int bonus){
        -: 1064:   int i;
        -: 1065:   //reset coin count
    #####: 1066:   state->coins = 0;
        -: 1067:   //add coins for each Treasure card in player's hand
    #####: 1068:   for (i = 0; i < state->handCount[player]; i++){
    #####: 1069:      if (state->hand[player][i] == copper){
    #####: 1070:         state->coins += 1;
        -: 1071:      }
    #####: 1072:      else if (state->hand[player][i] == silver){
    #####: 1073:         state->coins += 2;
        -: 1074:      }
    #####: 1075:      else if (state->hand[player][i] == gold){
    #####: 1076:         state->coins += 3;
        -: 1077:      }
        -: 1078:   }
        -: 1079:   //add bonus
    #####: 1080:   state->coins += bonus;
    #####: 1081:   return 0;
        -: 1082:}
        -: 1083:
        -: 1084://end of dominion.c
