All tests failed:

# Passed Tests: 0
# Failed Tests: 10000
Test Failure Results:

shuffle() failed: 0
drawCard() failed: 0
cardEffect() failed: 0
Treasure Count mismatch: 10000
Hand/Deck Count mismatch: 10000
COVERAGE: randomadventurer.c:
File 'randomadventurer.c'
Lines executed:87.84% of 74
Creating 'randomadventurer.c.gcov'

File 'dominion.c'
Lines executed:5.90% of 610
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
    #####:    8:int compare(const void* a, const void* b){
    #####:    9:   if (*(int*)a > *(int*)b)
    #####:   10:      return 1;
    #####:   11:   if (*(int*)a < *(int*)b)
    #####:   12:      return -1;
    #####:   13:   return 0;
        -:   14:}
        -:   15:
    #####:   16:struct gameState* newGame(){
    #####:   17:   struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:   return g;
        -:   19:}
        -:   20:
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8, int k9, int k10){
    #####:   22:   int* k = malloc(10 * sizeof(int));
    #####:   23:   k[0] = k1;
    #####:   24:   k[1] = k2;
    #####:   25:   k[2] = k3;
    #####:   26:   k[3] = k4;
    #####:   27:   k[4] = k5;
    #####:   28:   k[5] = k6;
    #####:   29:   k[6] = k7;
    #####:   30:   k[7] = k8;
    #####:   31:   k[8] = k9;
    #####:   32:   k[9] = k10;
    #####:   33:   return k;
        -:   34:}
        -:   35:
    #####:   36:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed, struct gameState *state){
        -:   37:   int i, j, it;
        -:   38:   //set up random number generator
    #####:   39:   SelectStream(1);
    #####:   40:   PutSeed((long)randomSeed);
        -:   41:   //check number of players
    #####:   42:   if (numPlayers > MAX_PLAYERS || numPlayers < 2)
    #####:   43:      return -1;
        -:   44:   //set number of players
    #####:   45:   state->numPlayers = numPlayers;
        -:   46:   //check selected kingdom cards are different
    #####:   47:   for (i = 0; i < 10; i++){
    #####:   48:      for (j = 0; j < 10; j++){
    #####:   49:         if (j != i && kingdomCards[j] == kingdomCards[i]){
    #####:   50:            return -1;
        -:   51:         }
        -:   52:      }
        -:   53:   }
        -:   54:   //initialize supply
        -:   55:   ///////////////////////////////
        -:   56:   //set number of Curse cards
    #####:   57:   if (numPlayers == 2)
    #####:   58:      state->supplyCount[curse] = 10;
    #####:   59:   else if (numPlayers == 3)
    #####:   60:      state->supplyCount[curse] = 20;
        -:   61:   else
    #####:   62:      state->supplyCount[curse] = 30;
        -:   63:
        -:   64:   //set number of Victory cards
    #####:   65:   if (numPlayers == 2){
    #####:   66:      state->supplyCount[estate] = 8;
    #####:   67:      state->supplyCount[duchy] = 8;
    #####:   68:      state->supplyCount[province] = 8;
        -:   69:   }
        -:   70:   else{
    #####:   71:      state->supplyCount[estate] = 12;
    #####:   72:      state->supplyCount[duchy] = 12;
    #####:   73:      state->supplyCount[province] = 12;
        -:   74:   }
        -:   75:   //set number of Treasure cards
    #####:   76:   state->supplyCount[copper] = 60 - (7 * numPlayers);
    #####:   77:   state->supplyCount[silver] = 40;
    #####:   78:   state->supplyCount[gold] = 30;
        -:   79:   //set number of Kingdom cards
    #####:   80:   for (i = adventurer; i <= treasure_map; i++){     	//loop all cards
    #####:   81:      for (j = 0; j < 10; j++){           		//loop chosen cards
    #####:   82:         if (kingdomCards[j] == i){
        -:   83:            //check if card is a 'Victory' Kingdom card
    #####:   84:            if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens){
    #####:   85:               if (numPlayers == 2){
    #####:   86:                  state->supplyCount[i] = 8;
        -:   87:               }
        -:   88:               else{
    #####:   89:                  state->supplyCount[i] = 12; }
        -:   90:            }
        -:   91:            else{
    #####:   92:               state->supplyCount[i] = 10;
        -:   93:            }
    #####:   94:            break;
        -:   95:         }
        -:   96:         else{    //card is not in the set choosen for the game
    #####:   97:            state->supplyCount[i] = -1;
        -:   98:         }
        -:   99:      }
        -:  100:   }
        -:  101:   ////////////////////////
        -:  102:   //supply intilization complete
        -:  103:   //set player decks
    #####:  104:   for (i = 0; i < numPlayers; i++){
    #####:  105:      state->deckCount[i] = 0;
    #####:  106:      for (j = 0; j < 3; j++){
    #####:  107:         state->deck[i][j] = estate;
    #####:  108:         state->deckCount[i]++;
        -:  109:      }
    #####:  110:      for (j = 3; j < 10; j++){
    #####:  111:         state->deck[i][j] = copper;
    #####:  112:         state->deckCount[i]++;
        -:  113:      }
        -:  114:   }
        -:  115:   //shuffle player decks
    #####:  116:   for (i = 0; i < numPlayers; i++){
    #####:  117:      if ( shuffle(i, state) < 0 ){
    #####:  118:         return -1;
        -:  119:      }
        -:  120:   }
        -:  121:
        -:  122:   //draw player hands
    #####:  123:   for (i = 0; i < numPlayers; i++){
        -:  124:      //initialize hand size to zero
    #####:  125:      state->handCount[i] = 0;
    #####:  126:      state->discardCount[i] = 0;
        -:  127:      //draw 5 cards
        -:  128:      // for (j = 0; j < 5; j++)
        -:  129:      //	{
        -:  130:      //	  drawCard(i, state);
        -:  131:      //	}
        -:  132:   }
        -:  133:   //set embargo tokens to 0 for all supply piles
    #####:  134:   for (i = 0; i <= treasure_map; i++){
    #####:  135:      state->embargoTokens[i] = 0;
        -:  136:   }
        -:  137:   //initialize first player's turn
    #####:  138:   state->outpostPlayed = 0;
    #####:  139:   state->phase = 0;
    #####:  140:   state->numActions = 1;
    #####:  141:   state->numBuys = 1;
    #####:  142:   state->playedCardCount = 0;
    #####:  143:   state->whoseTurn = 0;
    #####:  144:   state->handCount[state->whoseTurn] = 0;
        -:  145:   //int it; move to top
        -:  146:   //Moved draw cards to here, only drawing at the start of a turn
    #####:  147:   for (it = 0; it < 5; it++){
    #####:  148:      drawCard(state->whoseTurn, state);
        -:  149:   }
    #####:  150:   updateCoins(state->whoseTurn, state, 0);
    #####:  151:   return 0;
        -:  152:}
        -:  153:
    #####:  154:int shuffle(int player, struct gameState *state){
    #####:  155:   int newDeck[MAX_DECK], newDeckPos = 0, card, i;
    #####:  156:   if (state->deckCount[player] < 1)
    #####:  157:      return -1;
    #####:  158:   qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  159:   /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
    #####:  160:   while (state->deckCount[player] > 0){
    #####:  161:      card = floor(Random() * state->deckCount[player]);
    #####:  162:      newDeck[newDeckPos] = state->deck[player][card];
    #####:  163:      newDeckPos++;
    #####:  164:      for (i = card; i < state->deckCount[player]-1; i++){
    #####:  165:         state->deck[player][i] = state->deck[player][i+1];
        -:  166:      }
    #####:  167:      state->deckCount[player]--;
        -:  168:   }
    #####:  169:   for (i = 0; i < newDeckPos; i++){
    #####:  170:      state->deck[player][i] = newDeck[i];
    #####:  171:      state->deckCount[player]++;
        -:  172:   }
    #####:  173:   return 0;
        -:  174:}
        -:  175:
    #####:  176:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state){
        -:  177:   int card;
    #####:  178:   int coin_bonus = 0; 		//tracks coins gain from actions
        -:  179:   //check if it is the right phase
    #####:  180:   if (state->phase != 0){
    #####:  181:      return -1;
        -:  182:   }
        -:  183:   //check if player has enough actions
    #####:  184:   if ( state->numActions < 1 ){
    #####:  185:      return -1;
        -:  186:   }
        -:  187:   //get card played
    #####:  188:   card = handCard(handPos, state);
        -:  189:   //check if selected card is an action
    #####:  190:   if ( card < adventurer || card > treasure_map ){
    #####:  191:      return -1;
        -:  192:   }
        -:  193:   //play card
    #####:  194:   if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 ){
    #####:  195:      return -1;
        -:  196:   }
        -:  197:   //reduce number of actions
    #####:  198:   state->numActions--;
        -:  199:   //update coins (Treasure cards may be added with card draws)
    #####:  200:   updateCoins(state->whoseTurn, state, coin_bonus);
    #####:  201:   return 0;
        -:  202:}
        -:  203:
    #####:  204:int buyCard(int supplyPos, struct gameState *state){
        -:  205:   int who;
        -:  206:   if (DEBUG){
        -:  207:      printf("Entering buyCard...\n");
        -:  208:   }
        -:  209:   // I don't know what to do about the phase thing.
    #####:  210:   who = state->whoseTurn;
    #####:  211:   if (state->numBuys < 1){
        -:  212:      if (DEBUG)
        -:  213:      printf("You do not have any buys left\n");
    #####:  214:      return -1;
        -:  215:   }
    #####:  216:   else if (supplyCount(supplyPos, state) <1){
        -:  217:      if (DEBUG)
        -:  218:      printf("There are not any of that type of card left\n");
    #####:  219:      return -1;
        -:  220:   }
    #####:  221:   else if (state->coins < getCost(supplyPos)){
        -:  222:      if (DEBUG)
        -:  223:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  224:      return -1;
        -:  225:   }
        -:  226:   else{
    #####:  227:      state->phase=1;
        -:  228:      //state->supplyCount[supplyPos]--;
    #####:  229:      gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
    #####:  230:      state->coins = (state->coins) - (getCost(supplyPos));
    #####:  231:      state->numBuys--;
        -:  232:      if (DEBUG)
        -:  233:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  234:   }
        -:  235:
        -:  236:   //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  237:   //state->discardCount[who]++;
        -:  238:
    #####:  239:   return 0;
        -:  240:}
        -:  241:
    #####:  242:int numHandCards(struct gameState *state){
    #####:  243:   return state->handCount[ whoseTurn(state) ];
        -:  244:}
        -:  245:
    #####:  246:int handCard(int handPos, struct gameState *state){
    #####:  247:   int currentPlayer = whoseTurn(state);
    #####:  248:   return state->hand[currentPlayer][handPos];
        -:  249:}
        -:  250:
    #####:  251:int supplyCount(int card, struct gameState *state){
    #####:  252:   return state->supplyCount[card];
        -:  253:}
        -:  254:
    #####:  255:int fullDeckCount(int player, int card, struct gameState *state){
        -:  256:   int i;
    #####:  257:   int count = 0;
    #####:  258:   for (i = 0; i < state->deckCount[player]; i++){
    #####:  259:      if (state->deck[player][i] == card) count++;
        -:  260:   }
    #####:  261:   for (i = 0; i < state->handCount[player]; i++){
    #####:  262:      if (state->hand[player][i] == card) count++;
        -:  263:   }
    #####:  264:   for (i = 0; i < state->discardCount[player]; i++){
    #####:  265:      if (state->discard[player][i] == card) count++;
        -:  266:   }
    #####:  267:   return count;
        -:  268:}
        -:  269:
    10000:  270:int whoseTurn(struct gameState *state){
    10000:  271:   return state->whoseTurn;
        -:  272:}
        -:  273:
    #####:  274:int endTurn(struct gameState *state){
        -:  275:   int k, i;
    #####:  276:   int currentPlayer = whoseTurn(state);
        -:  277:   //Discard hand
    #####:  278:   for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  279:      state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  280:      state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  281:   }
    #####:  282:   state->handCount[currentPlayer] = 0;//Reset hand count
        -:  283:   //Code for determining the player
    #####:  284:   if (currentPlayer < (state->numPlayers - 1)){
    #####:  285:      state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  286:   }
        -:  287:   else{
    #####:  288:      state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  289:   }
    #####:  290:   state->outpostPlayed = 0;
    #####:  291:   state->phase = 0;
    #####:  292:   state->numActions = 1;
    #####:  293:   state->coins = 0;
    #####:  294:   state->numBuys = 1;
    #####:  295:   state->playedCardCount = 0;
    #####:  296:   state->handCount[state->whoseTurn] = 0;
        -:  297:   //int k; move to top
        -:  298:   //Next player draws hand
    #####:  299:   for (k = 0; k < 5; k++){
    #####:  300:      drawCard(state->whoseTurn, state);//Draw a card
        -:  301:   }
        -:  302:   //Update money
    #####:  303:   updateCoins(state->whoseTurn, state , 0);
    #####:  304:   return 0;
        -:  305:}
        -:  306:
    #####:  307:int isGameOver(struct gameState *state){
        -:  308:   int i, j;
        -:  309:   //if stack of Province cards is empty, the game ends
    #####:  310:   if (state->supplyCount[province] == 0){
    #####:  311:      return 1;
        -:  312:   }
        -:  313:   //if three supply pile are at 0, the game ends
    #####:  314:   j = 0;
    #####:  315:   for (i = 0; i < 25; i++){
    #####:  316:      if (state->supplyCount[i] == 0){
    #####:  317:         j++;
        -:  318:      }
        -:  319:   }
    #####:  320:   if ( j >= 3){
    #####:  321:      return 1;
        -:  322:   }
    #####:  323:   return 0;
        -:  324:}
        -:  325:
    #####:  326:int scoreFor (int player, struct gameState *state){
    #####:  327:   int i, score = 0;
        -:  328:   //score from hand
    #####:  329:   for (i = 0; i < state->handCount[player]; i++){
    #####:  330:      if (state->hand[player][i] == curse){ score = score - 1; };
    #####:  331:      if (state->hand[player][i] == estate){ score = score + 1; };
    #####:  332:      if (state->hand[player][i] == duchy){ score = score + 3; };
    #####:  333:      if (state->hand[player][i] == province){ score = score + 6; };
    #####:  334:      if (state->hand[player][i] == great_hall){ score = score + 1; };
    #####:  335:      if (state->hand[player][i] == gardens){ score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  336:   }
        -:  337:   //score from discard
    #####:  338:   for (i = 0; i < state->discardCount[player]; i++){
    #####:  339:      if (state->discard[player][i] == curse){ score = score - 1; };
    #####:  340:      if (state->discard[player][i] == estate){ score = score + 1; };
    #####:  341:      if (state->discard[player][i] == duchy){ score = score + 3; };
    #####:  342:      if (state->discard[player][i] == province){ score = score + 6; };
    #####:  343:      if (state->discard[player][i] == great_hall){ score = score + 1; };
    #####:  344:      if (state->discard[player][i] == gardens){ score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  345:   }
        -:  346:   //score from deck
    #####:  347:   for (i = 0; i < state->discardCount[player]; i++){
    #####:  348:      if (state->deck[player][i] == curse){ score = score - 1; };
    #####:  349:      if (state->deck[player][i] == estate){ score = score + 1; };
    #####:  350:      if (state->deck[player][i] == duchy){ score = score + 3; };
    #####:  351:      if (state->deck[player][i] == province){ score = score + 6; };
    #####:  352:      if (state->deck[player][i] == great_hall){ score = score + 1; };
    #####:  353:      if (state->deck[player][i] == gardens){ score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  354:   }
    #####:  355:   return score;
        -:  356:}
        -:  357:
    #####:  358:int getWinners(int players[MAX_PLAYERS], struct gameState *state){
        -:  359:   int i, j, highScore, currentPlayer;
        -:  360:   //get score for each player
    #####:  361:   for (i = 0; i < MAX_PLAYERS; i++){
        -:  362:      //set unused player scores to -9999
    #####:  363:      if (i >= state->numPlayers){
    #####:  364:         players[i] = -9999;
        -:  365:      }
        -:  366:      else{
    #####:  367:         players[i] = scoreFor (i, state);
        -:  368:      }
        -:  369:   }
        -:  370:   //find highest score
    #####:  371:   j = 0;
    #####:  372:   for (i = 0; i < MAX_PLAYERS; i++){
    #####:  373:      if (players[i] > players[j]){
    #####:  374:         j = i;
        -:  375:      }
        -:  376:   }
    #####:  377:   highScore = players[j];
        -:  378:   //add 1 to players who had less turns
    #####:  379:   currentPlayer = whoseTurn(state);
    #####:  380:   for (i = 0; i < MAX_PLAYERS; i++){
    #####:  381:      if ( players[i] == highScore && i > currentPlayer ){
    #####:  382:         players[i]++;
        -:  383:      }
        -:  384:   }
        -:  385:   //find new highest score
    #####:  386:   j = 0;
    #####:  387:   for (i = 0; i < MAX_PLAYERS; i++){
    #####:  388:      if ( players[i] > players[j] ){
    #####:  389:         j = i;
        -:  390:      }
        -:  391:   }
    #####:  392:   highScore = players[j];
        -:  393:   //set winners in array to 1 and rest to 0
    #####:  394:   for (i = 0; i < MAX_PLAYERS; i++){
    #####:  395:      if ( players[i] == highScore ){
    #####:  396:         players[i] = 1;
        -:  397:      }
        -:  398:      else{
    #####:  399:         players[i] = 0;
        -:  400:      }
        -:  401:   }
    #####:  402:   return 0;
        -:  403:}
        -:  404:
  2515556:  405:int drawCard(int player, struct gameState *state){
        -:  406:   int count, deckCounter;
  2515556:  407:   if (state->deckCount[player] <= 0){//Deck is empty
        -:  408:      //Step 1 Shuffle the discard pile back into a deck
        -:  409:      int i;
        -:  410:      //Move discard to deck
    #####:  411:      for (i = 0; i < state->discardCount[player];i++){
    #####:  412:         state->deck[player][i] = state->discard[player][i];
    #####:  413:         state->discard[player][i] = -1;
        -:  414:      }
    #####:  415:      state->deckCount[player] = state->discardCount[player];
    #####:  416:      state->discardCount[player] = 0;//Reset discard
        -:  417:      //Shufffle the deck
    #####:  418:      shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  419:      if (DEBUG){//Debug statements
        -:  420:         printf("Deck count now: %d\n", state->deckCount[player]);
        -:  421:      }
    #####:  422:      state->discardCount[player] = 0;
        -:  423:      //Step 2 Draw Card
    #####:  424:      count = state->handCount[player];//Get current player's hand count
        -:  425:      if (DEBUG){//Debug statements
        -:  426:         printf("Current hand count: %d\n", count);
        -:  427:      }
    #####:  428:      deckCounter = state->deckCount[player];//Create a holder for the deck count
    #####:  429:      if (deckCounter == 0)
    #####:  430:         return -1;
    #####:  431:      state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  432:      state->deckCount[player]--;
    #####:  433:      state->handCount[player]++;//Increment hand count
        -:  434:   }
        -:  435:   else{
  2515556:  436:      int count = state->handCount[player];//Get current hand count for player
        -:  437:      int deckCounter;
        -:  438:      if (DEBUG){//Debug statements
        -:  439:         printf("Current hand count: %d\n", count);
        -:  440:      }
  2515556:  441:      deckCounter = state->deckCount[player];//Create holder for the deck count
  2515556:  442:      state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
  2515556:  443:      state->deckCount[player]--;
  2515556:  444:      state->handCount[player]++;//Increment hand count
        -:  445:   }
  2515556:  446:   return 0;
        -:  447:}
        -:  448:
    #####:  449:int getCost(int cardNumber){
    #####:  450:   switch(cardNumber){
    #####:  451:      case curse:
    #####:  452:         return 0;
    #####:  453:      case estate:
    #####:  454:         return 2;
    #####:  455:      case duchy:
    #####:  456:         return 5;
    #####:  457:      case province:
    #####:  458:         return 8;
    #####:  459:      case copper:
    #####:  460:         return 0;
    #####:  461:      case silver:
    #####:  462:         return 3;
    #####:  463:      case gold:
    #####:  464:         return 6;
    #####:  465:      case adventurer:
    #####:  466:         return 6;
    #####:  467:      case council_room:
    #####:  468:         return 5;
    #####:  469:      case feast:
    #####:  470:         return 4;
    #####:  471:      case gardens:
    #####:  472:         return 4;
    #####:  473:      case mine:
    #####:  474:         return 5;
    #####:  475:      case remodel:
    #####:  476:         return 4;
    #####:  477:      case smithy:
    #####:  478:         return 4;
    #####:  479:      case village:
    #####:  480:         return 3;
    #####:  481:      case baron:
    #####:  482:         return 4;
    #####:  483:      case great_hall:
    #####:  484:         return 3;
    #####:  485:      case minion:
    #####:  486:         return 5;
    #####:  487:      case steward:
    #####:  488:         return 3;
    #####:  489:      case tribute:
    #####:  490:         return 5;
    #####:  491:      case ambassador:
    #####:  492:         return 3;
    #####:  493:      case cutpurse:
    #####:  494:         return 4;
    #####:  495:      case embargo:
    #####:  496:         return 2;
    #####:  497:      case outpost:
    #####:  498:         return 5;
    #####:  499:      case salvager:
    #####:  500:         return 4;
    #####:  501:      case sea_hag:
    #####:  502:         return 4;
    #####:  503:      case treasure_map:
    #####:  504:         return 4;
        -:  505:   }
    #####:  506:   return -1;
        -:  507:}
        -:  508:
    10000:  509:void adventurerCard(int currentPlayer, struct gameState *state, int temphand[], int z){
    10000:  510:   int drawntreasure=0;
        -:  511:   int cardDrawn;
        -:  512:   //TODO Bug that only draws one treasure instead of two
  1272778:  513:   while(drawntreasure<1){
  1252778:  514:      if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  515:         shuffle(currentPlayer, state);
        -:  516:      }
  1252778:  517:      drawCard(currentPlayer, state);
  1252778:  518:      cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
  1252778:  519:      if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    10000:  520:      drawntreasure++;
        -:  521:      else{
  1242778:  522:         temphand[z]=cardDrawn;
  1242778:  523:         state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
  1242778:  524:         z++;
        -:  525:      }
        -:  526:   }
  1262778:  527:   while(z-1>=0){
  1242778:  528:      state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
  1242778:  529:      z=z-1;
        -:  530:   }
    10000:  531:}
        -:  532:
    #####:  533:void smithyCard(int currentPlayer, struct gameState *state, int handPos){
        -:  534:   int i;
        -:  535:   //+3 Cards
        -:  536:   //TODO Bug fix here. Off by 1 error, where 4 cards are given instead of 3
    #####:  537:   for (i = 0; i <= 3; i++){
    #####:  538:      drawCard(currentPlayer, state);
        -:  539:   }
        -:  540:   //discard card from hand
    #####:  541:   discardCard(handPos, currentPlayer, state, 0);
    #####:  542:}
        -:  543:
    #####:  544:void councilRoomCard(int currentPlayer, struct gameState *state, int handPos){
        -:  545:   int i;
        -:  546:   //+4 Cards
        -:  547:   //TODO Bug off by 1 error. Adds one less card
    #####:  548:   for (i = 0; i < 3; i++){
    #####:  549:      drawCard(currentPlayer, state);
        -:  550:   }
        -:  551:   //+1 Buy
    #####:  552:   state->numBuys++;
        -:  553:   //Each other player draws a card
    #####:  554:   for (i = 0; i < state->numPlayers; i++){
    #####:  555:      if ( i != currentPlayer ){
    #####:  556:         drawCard(i, state);
        -:  557:      }
        -:  558:   }
        -:  559:   //put played card in played card pile
    #####:  560:   discardCard(handPos, currentPlayer, state, 0);
    #####:  561:}
        -:  562:
    #####:  563:void feastCard(int currentPlayer, struct gameState *state, int temphand[], int choice1){
        -:  564:   int i,x;
        -:  565:   //gain card with cost up to 5
        -:  566:   //Backup hand
    #####:  567:   for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  568:      temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  569:      state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  570:   }
        -:  571:   //Backup hand
        -:  572:   //Update Coins for Buy
    #####:  573:   updateCoins(currentPlayer, state, 5);
        -:  574:   //TODO Bug wrong loop condition
    #####:  575:   x = 0;//Condition to loop on
    #####:  576:   while( x == 1){//Buy one card
    #####:  577:      if (supplyCount(choice1, state) <= 0){
        -:  578:         if (DEBUG)
        -:  579:            printf("None of that card left, sorry!\n");
        -:  580:         if (DEBUG){
        -:  581:            printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  582:         }
        -:  583:      }
    #####:  584:      else if (state->coins < getCost(choice1)){
    #####:  585:         printf("That card is too expensive!\n");
        -:  586:         if (DEBUG){
        -:  587:            printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  588:         }
        -:  589:      }
        -:  590:      else{
        -:  591:         if (DEBUG){
        -:  592:            printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  593:         }
    #####:  594:         gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  595:         x = 0;//No more buying cards
        -:  596:         if (DEBUG){
        -:  597:            printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  598:         }
        -:  599:
        -:  600:      }
        -:  601:   }
        -:  602:   //Reset Hand
    #####:  603:   for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  604:      state->hand[currentPlayer][i] = temphand[i];
    #####:  605:      temphand[i] = -1;
        -:  606:   }
        -:  607:   //Reset Hand
    #####:  608:}
        -:  609:
    #####:  610:int mineCard(int currentPlayer, struct gameState *state, int handPos, int choice1, int choice2){
        -:  611:   int i, j;
    #####:  612:   j = state->hand[currentPlayer][choice1];  //store card we will trash
    #####:  613:   if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold){
    #####:  614:      return -1;
        -:  615:   }
    #####:  616:   if (choice2 > treasure_map || choice2 < curse){
    #####:  617:      return -1;
        -:  618:   }
    #####:  619:   if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) ){
    #####:  620:      return -1;
        -:  621:   }
    #####:  622:   gainCard(choice1, state, 1, currentPlayer);
        -:  623:   //discard card from hand
    #####:  624:   discardCard(handPos, currentPlayer, state, 0);
        -:  625:   //discard trashed card
    #####:  626:   for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  627:      if (state->hand[currentPlayer][i] == j){
    #####:  628:         discardCard(i, currentPlayer, state, 0);
    #####:  629:         break;
        -:  630:      }
        -:  631:   }
    #####:  632:   return 0;
        -:  633:}
        -:  634:
    10000:  635:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus){
        -:  636:   int i, j, k, index, y;
    10000:  637:   int currentPlayer = whoseTurn(state);
    10000:  638:   int nextPlayer = currentPlayer + 1;
    10000:  639:   int tributeRevealedCards[2] ={-1, -1};
        -:  640:   int temphand[MAX_HAND];// moved above the if statement
        -:  641:   //int x
        -:  642:   //int drawntreasure=0;
        -:  643:   //int cardDrawn;
    10000:  644:   int z = 0;// this is the counter for the temp hand
    10000:  645:   if (nextPlayer > (state->numPlayers - 1)){
     4977:  646:      nextPlayer = 0;
        -:  647:   }
        -:  648:   //uses switch to select card and perform actions
    10000:  649:   switch( card ){
    10000:  650:      case adventurer:
    10000:  651:         adventurerCard(currentPlayer, state, temphand, z);
    10000:  652:         return 0;
        -:  653:
    #####:  654:      case council_room:
    #####:  655:         councilRoomCard(currentPlayer, state, handPos);
    #####:  656:         return 0;
        -:  657:
    #####:  658:      case feast:
    #####:  659:         feastCard(currentPlayer, state, temphand, choice1);
    #####:  660:         return 0;
        -:  661:
    #####:  662:      case gardens:
    #####:  663:         return -1;
        -:  664:
    #####:  665:      case mine:
    #####:  666:         y = mineCard(currentPlayer, state, handPos, choice1, choice2);
    #####:  667:         return y;
        -:  668:
    #####:  669:      case remodel:
    #####:  670:         j = state->hand[currentPlayer][choice1];  //store card we will trash
    #####:  671:         if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) ){
    #####:  672:            return -1;
        -:  673:         }
    #####:  674:         gainCard(choice2, state, 0, currentPlayer);
        -:  675:         //discard card from hand
    #####:  676:         discardCard(handPos, currentPlayer, state, 0);
        -:  677:         //discard trashed card
    #####:  678:         for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  679:            if (state->hand[currentPlayer][i] == j){
    #####:  680:               discardCard(i, currentPlayer, state, 0);
    #####:  681:               break;
        -:  682:            }
        -:  683:         }
    #####:  684:         return 0;
        -:  685:
    #####:  686:      case smithy:
    #####:  687:         smithyCard(currentPlayer, state, handPos);
    #####:  688:         return 0;
        -:  689:
    #####:  690:      case village:
        -:  691:         //+1 Card
    #####:  692:         drawCard(currentPlayer, state);
        -:  693:         //+2 Actions
    #####:  694:         state->numActions = state->numActions + 2;
        -:  695:         //discard played card from hand
    #####:  696:         discardCard(handPos, currentPlayer, state, 0);
    #####:  697:         return 0;
        -:  698:
    #####:  699:      case baron:
    #####:  700:         state->numBuys++;//Increase buys by 1!
    #####:  701:         if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  702:            int p = 0;//Iterator for hand!
    #####:  703:            int card_not_discarded = 1;//Flag for discard set!
    #####:  704:            while(card_not_discarded){
    #####:  705:               if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:  706:                  state->coins += 4;//Add 4 coins to the amount of coins
    #####:  707:                  state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  708:                  state->discardCount[currentPlayer]++;
    #####:  709:                  for (;p < state->handCount[currentPlayer]; p++){
    #####:  710:                     state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  711:                  }
    #####:  712:                  state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  713:                  state->handCount[currentPlayer]--;
    #####:  714:                  card_not_discarded = 0;//Exit the loop
        -:  715:               }
    #####:  716:               else if (p > state->handCount[currentPlayer]){
        -:  717:                  if(DEBUG){
        -:  718:                     printf("No estate cards in your hand, invalid choice\n");
        -:  719:                     printf("Must gain an estate if there are any\n");
        -:  720:                  }
    #####:  721:                  if (supplyCount(estate, state) > 0){
    #####:  722:                     gainCard(estate, state, 0, currentPlayer);
    #####:  723:                     state->supplyCount[estate]--;//Decrement estates
    #####:  724:                     if (supplyCount(estate, state) == 0){
    #####:  725:                        isGameOver(state);
        -:  726:                     }
        -:  727:                  }
    #####:  728:                  card_not_discarded = 0;//Exit the loop
        -:  729:               }
        -:  730:               else{
    #####:  731:                  p++;//Next card
        -:  732:               }
        -:  733:            }
        -:  734:         }
        -:  735:         else{
    #####:  736:            if (supplyCount(estate, state) > 0){
    #####:  737:               gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  738:               state->supplyCount[estate]--;//Decrement Estates
    #####:  739:               if (supplyCount(estate, state) == 0){
    #####:  740:                  isGameOver(state);
        -:  741:               }
        -:  742:            }
        -:  743:         }
    #####:  744:         return 0;
        -:  745:
    #####:  746:      case great_hall:
        -:  747:         //+1 Card
    #####:  748:         drawCard(currentPlayer, state);
        -:  749:         //+1 Actions
    #####:  750:         state->numActions++;
        -:  751:         //discard card from hand
    #####:  752:         discardCard(handPos, currentPlayer, state, 0);
    #####:  753:         return 0;
        -:  754:
    #####:  755:      case minion:
        -:  756:         //+1 action
    #####:  757:         state->numActions++;
        -:  758:         //discard card from hand
    #####:  759:         discardCard(handPos, currentPlayer, state, 0);
    #####:  760:         if (choice1){		//+2 coins
    #####:  761:            state->coins = state->coins + 2;
        -:  762:         }
    #####:  763:         else if (choice2){		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  764:            //discard hand
    #####:  765:            while(numHandCards(state) > 0){
    #####:  766:               discardCard(handPos, currentPlayer, state, 0);
        -:  767:            }
        -:  768:            //draw 4
    #####:  769:            for (i = 0; i < 4; i++){
    #####:  770:               drawCard(currentPlayer, state);
        -:  771:            }
        -:  772:            //other players discard hand and redraw if hand size > 4
    #####:  773:            for (i = 0; i < state->numPlayers; i++){
    #####:  774:               if (i != currentPlayer){
    #####:  775:                  if ( state->handCount[i] > 4 ){
        -:  776:                     //discard hand
    #####:  777:                     while( state->handCount[i] > 0 ){
    #####:  778:                        discardCard(handPos, i, state, 0);
        -:  779:                     }
        -:  780:                     //draw 4
    #####:  781:                     for (j = 0; j < 4; j++){
    #####:  782:                        drawCard(i, state);
        -:  783:                     }
        -:  784:                  }
        -:  785:               }
        -:  786:            }
        -:  787:         }
    #####:  788:         return 0;
        -:  789:
    #####:  790:      case steward:
    #####:  791:         if (choice1 == 1){
        -:  792:            //+2 cards
    #####:  793:            drawCard(currentPlayer, state);
    #####:  794:            drawCard(currentPlayer, state);
        -:  795:         }
    #####:  796:         else if (choice1 == 2){
        -:  797:            //+2 coins
    #####:  798:            state->coins = state->coins + 2;
        -:  799:         }
        -:  800:         else{
        -:  801:            //trash 2 cards in hand
    #####:  802:            discardCard(choice2, currentPlayer, state, 1);
    #####:  803:            discardCard(choice3, currentPlayer, state, 1);
        -:  804:         }
        -:  805:         //discard card from hand
    #####:  806:         discardCard(handPos, currentPlayer, state, 0);
    #####:  807:         return 0;
        -:  808:
    #####:  809:      case tribute:
    #####:  810:         if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  811:            if (state->deckCount[nextPlayer] > 0){
    #####:  812:               tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  813:               state->deckCount[nextPlayer]--;
        -:  814:            }
    #####:  815:            else if (state->discardCount[nextPlayer] > 0){
    #####:  816:               tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  817:               state->discardCount[nextPlayer]--;
        -:  818:            }
        -:  819:            else{
        -:  820:               //No Card to Reveal
        -:  821:               if (DEBUG){
        -:  822:                  printf("No cards to reveal\n");
        -:  823:               }
        -:  824:            }
        -:  825:         }
        -:  826:         else{
    #####:  827:            if (state->deckCount[nextPlayer] == 0){
    #####:  828:               for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  829:                  state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  830:                  state->deckCount[nextPlayer]++;
    #####:  831:                  state->discard[nextPlayer][i] = -1;
    #####:  832:                  state->discardCount[nextPlayer]--;
        -:  833:               }
    #####:  834:               shuffle(nextPlayer,state);//Shuffle the deck
        -:  835:            }
    #####:  836:            tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  837:            state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  838:            state->deckCount[nextPlayer]--;
    #####:  839:            tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  840:            state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  841:            state->deckCount[nextPlayer]--;
        -:  842:         }
    #####:  843:         if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one
    #####:  844:            state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  845:            state->playedCardCount++;
    #####:  846:            tributeRevealedCards[1] = -1;
        -:  847:         }
    #####:  848:         for (i = 0; i <= 2; i ++){
    #####:  849:            if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####:  850:               state->coins += 2;
        -:  851:            }
    #####:  852:            else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####:  853:               drawCard(currentPlayer, state);
    #####:  854:               drawCard(currentPlayer, state);
        -:  855:            }
        -:  856:            else{//Action Card
    #####:  857:               state->numActions = state->numActions + 2;
        -:  858:            }
        -:  859:         }
    #####:  860:         return 0;
        -:  861:
    #####:  862:      case ambassador:
    #####:  863:         j = 0;		//used to check if player has enough cards to discard
    #####:  864:         if (choice2 > 2 || choice2 < 0){
    #####:  865:            return -1;
        -:  866:         }
    #####:  867:         if (choice1 == handPos){
    #####:  868:            return -1;
        -:  869:         }
    #####:  870:         for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  871:            if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1){
    #####:  872:               j++;
        -:  873:            }
        -:  874:         }
    #####:  875:         if (j < choice2){
    #####:  876:            return -1;
        -:  877:         }
        -:  878:         if (DEBUG)
        -:  879:         printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  880:         //increase supply count for choosen card by amount being discarded
    #####:  881:         state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  882:         //each other player gains a copy of revealed card
    #####:  883:         for (i = 0; i < state->numPlayers; i++){
    #####:  884:            if (i != currentPlayer){
    #####:  885:               gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -:  886:            }
        -:  887:         }
        -:  888:         //discard played card from hand
    #####:  889:         discardCard(handPos, currentPlayer, state, 0);
        -:  890:         //trash copies of cards returned to supply
    #####:  891:         for (j = 0; j < choice2; j++){
    #####:  892:            for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  893:               if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1]){
    #####:  894:                  discardCard(i, currentPlayer, state, 1);
    #####:  895:                  break;
        -:  896:               }
        -:  897:            }
        -:  898:         }
    #####:  899:         return 0;
        -:  900:
    #####:  901:      case cutpurse:
    #####:  902:         updateCoins(currentPlayer, state, 2);
    #####:  903:         for (i = 0; i < state->numPlayers; i++){
    #####:  904:            if (i != currentPlayer){
    #####:  905:               for (j = 0; j < state->handCount[i]; j++){
    #####:  906:                  if (state->hand[i][j] == copper){
    #####:  907:                     discardCard(j, i, state, 0);
    #####:  908:                     break;
        -:  909:                  }
    #####:  910:                  if (j == state->handCount[i]){
    #####:  911:                     for (k = 0; k < state->handCount[i]; k++){
        -:  912:                        if (DEBUG)
        -:  913:                        printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -:  914:                     }
    #####:  915:                     break;
        -:  916:                  }
        -:  917:               }
        -:  918:
        -:  919:            }
        -:  920:
        -:  921:         }
        -:  922:         //discard played card from hand
    #####:  923:         discardCard(handPos, currentPlayer, state, 0);
    #####:  924:         return 0;
        -:  925:
    #####:  926:      case embargo:
        -:  927:         //+2 Coins
    #####:  928:         state->coins = state->coins + 2;
        -:  929:         //see if selected pile is in play
    #####:  930:         if ( state->supplyCount[choice1] == -1 ){
    #####:  931:            return -1;
        -:  932:         }
        -:  933:         //add embargo token to selected supply pile
    #####:  934:         state->embargoTokens[choice1]++;
        -:  935:         //trash card
    #####:  936:         discardCard(handPos, currentPlayer, state, 1);
    #####:  937:         return 0;
        -:  938:
    #####:  939:      case outpost:
        -:  940:         //set outpost flag
    #####:  941:         state->outpostPlayed++;
        -:  942:         //discard card
    #####:  943:         discardCard(handPos, currentPlayer, state, 0);
    #####:  944:         return 0;
        -:  945:
    #####:  946:      case salvager:
        -:  947:         //+1 buy
    #####:  948:         state->numBuys++;
    #####:  949:         if (choice1){
        -:  950:            //gain coins equal to trashed card
    #####:  951:            state->coins = state->coins + getCost( handCard(choice1, state) );
        -:  952:            //trash card
    #####:  953:            discardCard(choice1, currentPlayer, state, 1);
        -:  954:         }
        -:  955:         //discard card
    #####:  956:         discardCard(handPos, currentPlayer, state, 0);
    #####:  957:         return 0;
        -:  958:
    #####:  959:      case sea_hag:
    #####:  960:         for (i = 0; i < state->numPlayers; i++){
    #####:  961:            if (i != currentPlayer){
    #####:  962:               state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####:  963:               state->discardCount[i]++;
    #####:  964:               state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -:  965:            }
        -:  966:         }
    #####:  967:         return 0;
        -:  968:
    #####:  969:      case treasure_map:
        -:  970:         //search hand for another treasure_map
    #####:  971:         index = -1;
    #####:  972:         for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  973:            if (state->hand[currentPlayer][i] == treasure_map && i != handPos){
    #####:  974:               index = i;
    #####:  975:               break;
        -:  976:            }
        -:  977:         }
    #####:  978:         if (index > -1){
        -:  979:            //trash both treasure cards
    #####:  980:            discardCard(handPos, currentPlayer, state, 1);
    #####:  981:            discardCard(index, currentPlayer, state, 1);
        -:  982:
        -:  983:            //gain 4 Gold cards
    #####:  984:            for (i = 0; i < 4; i++){
    #####:  985:               gainCard(gold, state, 1, currentPlayer);
        -:  986:            }
        -:  987:            //return success
    #####:  988:            return 1;
        -:  989:         }
        -:  990:         //no second treasure_map found in hand
    #####:  991:         return -1;
        -:  992:   }
        -:  993:
    #####:  994:   return -1;
        -:  995:}
        -:  996:
    #####:  997:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag){
        -:  998:   //if card is not trashed, added to Played pile
    #####:  999:   if (trashFlag < 1){
        -: 1000:      //add card to played pile
    #####: 1001:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
    #####: 1002:      state->playedCardCount++;
        -: 1003:   }
        -: 1004:   //set played card to -1
    #####: 1005:   state->hand[currentPlayer][handPos] = -1;
        -: 1006:   //remove card from player's hand
    #####: 1007:   if ( handPos == (state->handCount[currentPlayer] - 1) ){ 	//last card in hand array is played
        -: 1008:      //reduce number of cards in hand
    #####: 1009:      state->handCount[currentPlayer]--;
        -: 1010:   }
    #####: 1011:   else if ( state->handCount[currentPlayer] == 1 ){ //only one card in hand
        -: 1012:      //reduce number of cards in hand
    #####: 1013:      state->handCount[currentPlayer]--;
        -: 1014:   }
        -: 1015:   else{
        -: 1016:      //replace discarded card with last card in hand
    #####: 1017:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1018:      //set last card to -1
    #####: 1019:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1020:      //reduce number of cards in hand
    #####: 1021:      state->handCount[currentPlayer]--;
        -: 1022:   }
    #####: 1023:   return 0;
        -: 1024:}
        -: 1025:
    #####: 1026:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player){
        -: 1027:   //Note: supplyPos is enum of choosen card
        -: 1028:   //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1029:   if ( supplyCount(supplyPos, state) < 1 ){
    #####: 1030:      return -1;
        -: 1031:   }
        -: 1032:   //added card for [whoseTurn] current player:
        -: 1033:   // toFlag = 0 : add to discard
        -: 1034:   // toFlag = 1 : add to deck
        -: 1035:   // toFlag = 2 : add to hand
    #####: 1036:   if (toFlag == 1){
    #####: 1037:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1038:      state->deckCount[player]++;
        -: 1039:   }
    #####: 1040:   else if (toFlag == 2){
    #####: 1041:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1042:      state->handCount[player]++;
        -: 1043:   }
        -: 1044:   else{
    #####: 1045:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1046:      state->discardCount[player]++;
        -: 1047:   }
        -: 1048:   //decrease number in supply pile
    #####: 1049:   state->supplyCount[supplyPos]--;
    #####: 1050:   return 0;
        -: 1051:}
        -: 1052:
    #####: 1053:int updateCoins(int player, struct gameState *state, int bonus){
        -: 1054:   int i;
        -: 1055:   //reset coin count
    #####: 1056:   state->coins = 0;
        -: 1057:   //add coins for each Treasure card in player's hand
    #####: 1058:   for (i = 0; i < state->handCount[player]; i++){
    #####: 1059:      if (state->hand[player][i] == copper){
    #####: 1060:         state->coins += 1;
        -: 1061:      }
    #####: 1062:      else if (state->hand[player][i] == silver){
    #####: 1063:         state->coins += 2;
        -: 1064:      }
    #####: 1065:      else if (state->hand[player][i] == gold){
    #####: 1066:         state->coins += 3;
        -: 1067:      }
        -: 1068:   }
        -: 1069:   //add bonus
    #####: 1070:   state->coins += bonus;
    #####: 1071:   return 0;
        -: 1072:}
        -: 1073:
        -: 1074://end of dominion.c
